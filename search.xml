<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git必知必会-分支合并那些事</title>
      <link href="2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>小菜</strong>：“大鸟我最近碰到一件怪事”</p><p><strong>大鸟</strong>：“哦？说来听听。”</p><p><strong>小菜</strong>：“事情是这样的…”</p><p><strong>旁白</strong>：<br>  如下图，小菜基于 master 分支的提交 C1 迁出了一条新分支 dev，并添加了 feature.js（D1），这是一个新功能；</p><p>  然后他切换到 master 分支，发现此时同事有一个新提交 C2。小菜很自信，他直接把自己的 dev 分支合了过来（E1），然后发布到了测试环境。</p><p>  第二天，QA 提了 bug，小菜排查后发现是由于昨天添加了 feature.js 的原因，所以小菜只好把昨天的提交（E1） revert 了（E2）；</p><p>  之后小菜切换到自己的 dev 分支修复 fuature.js 的问题。他添加了一个 fix.js 并 import 了 feature.js。</p><p>  这次小菜长了心眼，在合并 dev 分支后（F），他在本地自测了一下。但奇怪的是，他发现合并后自己的 feature.js 文件消失了！</p><p>  <img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/example.drawio.png"></p><p><strong>大鸟</strong>：“我知道了，要解决这个问题，我们得先了解一下分支合并的一些相关知识…”</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>为什么小菜的 feature.js 会丢失？</li><li>怎样操作才能正常合并 dev 分支到 master？</li></ol><h2 id="三路合并（Three-way-merge）"><a href="#三路合并（Three-way-merge）" class="headerlink" title="三路合并（Three-way merge）"></a>三路合并（Three-way merge）</h2><p>首先我们先来了解一下三路合并算法，这是文件合并的常用算法。</p><p>以下内容引用自<a href="https://zh.wikipedia.org/wiki/%E5%90%88%E5%B9%B6_(%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)#%E4%B8%89%E8%B7%AF%E5%90%88%E5%B9%B6">维基百科</a>：</p><blockquote><p>三路合并（three-way merge），首先考虑对文件 A、文件 B 以及它们的共同祖先文件 C 做差异分析。</p><p>对于文件中的每节(sector)，如果上述三个文件中有两个文件该节的内容一致，那么抛弃文件 C 中该节的内容，保留与文件 C 中不同的内容放到结果文件中。</p><p>如果该节在三个文件中都不同，那么这个冲突需要手工合并。</p></blockquote><p>举个例子：</p><p><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/three-way-merge.drawio.png"></p><p>如图所示，因为 base 版本和 ours 版本的内容一致，所以我们最终选择 theirs 版本做为合并结果。</p><h2 id="Git-合并策略"><a href="#Git-合并策略" class="headerlink" title="Git 合并策略"></a>Git 合并策略</h2><p>接下来我们了解一下 Git 的合并策略，包括：<strong>Fast-forward、Recursive、Ours、Theirs、Octopus</strong> 等</p><h3 id="Fast-forward"><a href="#Fast-forward" class="headerlink" title="Fast-forward"></a><strong>Fast-forward</strong></h3><p>Fast-forward 是一个比较简单的合并策略。它的核心内容是：<br><strong>在分支合并时，如果发现<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88_(%E5%9B%BE%E8%AE%BA)">最近公共祖先</a>就是它们其中之一，就会直接移动文件指针，不产生新的提交</strong></p><h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a><strong>Recursive</strong></h3><p>Recursive 也被称为递归三路合并，是 Git 分支合并中最常用的策略。<br>核心内容是：<strong>递归寻找最近公共祖先，并以其为 base 节点，进行递归三路合并。</strong><br>下面我们来看几个例子：</p><blockquote><p>注：以下所有 Git 提交树，都以其节点名称作为文件内容</p></blockquote><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a><strong>一个简单的例子</strong></h4><p><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/simple-recursive.drawio.png"></p><p>当我们要合并中间两个提交 A、B 时，会去寻找他们的最近公共祖先，所以就找到了左边的 A 节点；</p><p>以它为 base 节点，根据三路合并算法，最后的合并结果为 B。</p><p><strong>小菜</strong>：“不是说叫做递归三路合并吗，这里完全没有递归操作啊？”</p><p><strong>大鸟</strong>：“别急，下面我们来看一个更加复杂的例子。”</p><h4 id="一个复杂的例子"><a href="#一个复杂的例子" class="headerlink" title="一个复杂的例子"></a><strong>一个复杂的例子</strong></h4><p>但实际情况往往没那么简单，可能出现层级较深、复杂交叉等情况。如下图：</p><p><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/complex-recursive.drawio.png"></p><p>我们发现，在合并 BC 节点的时候，出现了两个最近公共祖先，分别为 A、B，如下图：</p><p><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/path-analysis-compare.drawio.png"></p><p>所以我们需要再递归，直至寻找到唯一的最近公共祖先，为最左边的 A 节点。</p><p>那么我们的合并节点和顺序就可以确定了，如下图：</p><p><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/merge-element.drawio.png"></p><p><strong>首先我们以 A 为 base，合并 AB 节点，得到一个临时节点，根据三路合并算法，它的结果是 B。</strong></p><p><strong>然后以这个临时节点 B 为 base，合并 BC 节点，得到最终结果为 C。</strong></p><h3 id="Ours"><a href="#Ours" class="headerlink" title="Ours"></a><strong>Ours</strong></h3><p>Ours 的合并策略比较简单。它的核心内容是：<strong>丢弃目标分支的内容，采用当前分支的内容</strong></p><p>所以在这种合并策略下，<strong>最后的内容和没有合并时的当前分支的内容是一样的</strong>。</p><blockquote><p>注：Ours 策略和 <code>-Xours</code> 参数不一样， Ours 策略无论有没有冲突发生，都会丢弃目标分支的修改。<br>而 <code>-Xours</code> 参数则是仅在出现冲突时这么处理。</p></blockquote><h3 id="Theirs"><a href="#Theirs" class="headerlink" title="Theirs"></a><strong>Theirs</strong></h3><p><strong>该策略目前已不可用，仅在旧版本的 Git 中存在！</strong><br>Theirs 和 Ours 类似，只是保留内容的目标变了。它的核心内容是：<strong>丢弃当前分支的内容，采用目标分支的内容</strong></p><p>所以在这种合并策略下，<strong>最后的内容和没有合并时的目标分支的内容是一样的</strong>。</p><h3 id="Octopus"><a href="#Octopus" class="headerlink" title="Octopus"></a><strong>Octopus</strong></h3><p>这个策略的意思是章鱼。顾名思义，这种策略可以用于合并多条分支。不过，如果出现需要手工解决的冲突，操作将执行失败。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>那么回到我们最开始的例子以及问题</p><p><strong>大鸟</strong>：“小菜，现在知道为什么你的合并操作结果不对了吗？”</p><p><strong>小菜</strong>：知道了，我们首先寻找 D2 和 E2 的最近公共祖先，为 D1，如下图</p><p><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/example-path-analysis.drawio.png"></p><p>D1 不符合使用 Fast-forward 策略的条件， 所以根据 recursive 策略， 以 D1 为 base 节点，对 D1、D2、E2 进行差异分析：</p><ul><li><p>D2 的变更是：添加了 fix.js；</p></li><li><p>E2 的变更是：删除了 feature.js（这里 revert 等同与删除）。</p></li></ul><p>所以根据三路合并算法，<strong>两个文件的变更都被自动合并了</strong>，所以 feature.js 被删除了</p><p><strong>大鸟</strong>：“说得没错，但这只是对错误进行解释，并不是根本原因”</p><p><strong>小菜</strong>：“那根本原因是什么呢？”</p><p><strong>大鸟</strong>：“根本原因就是你在 dev 分支上开发的时候，内容并不是最新的”</p><p><strong>小菜</strong>：“我知道了！所以我的 dev 分支应该先拉取 master 的最新代码，再进行开发；<br>这样我在合并的时候就根本不会使用 Recursive 策略，而是根据 Fast-forward 策略合并就好了！”</p><p><strong>大鸟</strong>：“不错不错，孺子可教也…”</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/192972614">这才是真正的 Git——分支合并</a></li><li><a href="https://marsishandsome.github.io/2019/07/Three_Way_Merge">Git三路合并算法(Three Way Merge)</a></li><li><a href="https://book.douban.com/subject/2334288//">大话设计模式-程杰</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%90%88%E5%B9%B6_(%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)">维基百科-合并 (版本控制)</a></li></ul><h2 id="附1：merge-和-rebase-的区别"><a href="#附1：merge-和-rebase-的区别" class="headerlink" title="附1：merge 和 rebase 的区别"></a>附1：merge 和 rebase 的区别</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge 操作会生成新节点，并保留每个提交历史的祖先。</p><p><strong>优点</strong>：</p><ul><li>使用简单，易于理解。</li><li>能够记录 commit 、分支历史情况。</li></ul><p><strong>缺点</strong>：</p><ul><li>历史记录会比较杂乱。</li></ul><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>rebase 是将一个分支的修改重写到另一个分支上，不需要创建新的提交。</p><p><strong>优点</strong>：</p><ul><li>能够合并 commit 历史</li><li>易于制造更加干净、线性的提交树</li></ul><p><strong>缺点</strong>：</p><ul><li>会改写历史记录，可能会丢失上下文。</li></ul><h2 id="附2：cherry-pick-详解"><a href="#附2：cherry-pick-详解" class="headerlink" title="附2：cherry-pick 详解"></a>附2：cherry-pick 详解</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将某些提交<strong>复制</strong>到当前分支上。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>小菜最近接到了一个新需求，需要引用一个外部库 demo.js。他开了一条新分支 demo，在该分支上进行新需求的开发。</p><p>由于他不熟悉这个库，所以在开发过程中，他添加了一些测试代码，<strong>这些测试代码分散在不同的提交记录中</strong>。</p><p>某一天，这个新需求开发好了，小菜准备将分支合并到 develop 上，然后提交代码。</p><p><strong>但是总不能将测试代码也一起提交吧？或者手动删除？不行，效率太低，小菜犯愁了。</strong></p><p>这时，小菜的同事建议可以使用 <code>cherry-pick</code>，小菜赶紧了解了一下，发现还真的能够快速解决问题。</p><p><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/cherry-pick-example.drawio.png"></p><p>如上图所示，提交记录中 M 开头的表示 demo 分支的主要功能，是需要被合并到 develop 分支的；</p><p>而 T 开头的则是测试代码，这些提交是不想合并到 develop 分支的。</p><p>所以小菜切换到 develop 分支并运行了如下命令，解决了这个问题：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git cherry-pick M1 M2</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>现在我们来看一下 cherry-pick 这个命令的优缺点。</p><p><strong>优点</strong>：能够快速进行提交的复制、移动</p><p><strong>缺点</strong>：由于 cherry-pick 是 <strong>复制</strong> 提交，而不是合并。<br>所以如果分支并行地进行开发，在合并时可能会出现问题，<strong>而且不会出现冲突提示。</strong>我们来看一个简单的例子：</p><blockquote><p>注：这里提交节点附近的文字代表文件内容</p></blockquote><p><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/cherry-pick-merge-error-example.drawio.png"></p><p>如上图，在节点 C 我们使用了 cherry-pick 从 dev 分支复制了 E 节点到 master 分支（<strong>这里虚线代表进行 cherry-pick 操作，不代表 merge</strong>）。</p><p>然后我们在 dev 分支修改了文件内容，变为 cherry，此时将 dev 分支合并到 master。</p><p>我们很容易知道 CF 的最近公共祖先为 A，根据三路合并算法，所以最终的合并结果为 pick，这并不是我们所期望的。</p><p>而如果是合并操作，那么 CF 的最近公共祖先则是 E 节点，此时根据三路合并算法，结果就变成 cherry 了，这是正确的结果。</p><p><strong>所以我们在使用 cherry-pick 时，需要注意使用场景，不能盲目使用。</strong></p><h2 id="附3：merge-和-rebase-相关参数"><a href="#附3：merge-和-rebase-相关参数" class="headerlink" title="附3：merge 和 rebase 相关参数"></a>附3：merge 和 rebase 相关参数</h2><h3 id="merge-1"><a href="#merge-1" class="headerlink" title="merge"></a>merge</h3><ul><li><p><code>--stat</code> 和 <code>-n</code> 以及 <code>--no-stat</code></p><ul><li><p><code>--stat</code> 参数会在合并的提交信息后附加文件差异信息（默认就是会附加的，信息如下图）<br><img src="/2021/03/21/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E9%82%A3%E4%BA%9B%E4%BA%8B/file-change.drawio.png"></p></li><li><p><code>-n</code>、 <code>--no-stat</code> 与 <code>--stat</code> 相反，不附加文件差异信息</p></li></ul></li><li><p><code>--squash</code> 和 <code>--no-squash</code></p><ul><li><p><code>--squash</code> 参数表示会将被合并的分支提交压缩在一起成为一个新节点，并需要重新确认提交信息。</p></li><li><p><code>--no-squash</code> 则相反。</p></li></ul><blockquote><p>注: 该操作会改变 author</p></blockquote></li><li><p><code>--commit</code> 和 <code>--no-commit</code></p><ul><li><p><code>--commit</code> 参数表示在合并后会自动进行提交。</p></li><li><p><code>--no-commit</code> 参数则相反，不进行自动提交。</p></li></ul></li><li><p><code>--e</code>, <code>--edit</code> 和 <code>--no-edit</code></p><ul><li><p><code>--e</code>、 <code>--edit</code> 表示在成功合并前进行合并信息的编辑。</p></li><li><p><code>--no-edit</code> 则相反，即使用自动合并的信息。</p></li></ul></li><li><p><code>--ff</code> 和 <code>--no-ff</code> 以及 <code>--ff-only</code></p><ul><li><p><code>--ff</code> 指 fast-forward 模式，使用该模式进行合并时将不会创造一个新的提交节点。</p></li><li><p><code>--no-ff</code> 则相反，在合并时会创建一个新的提交节点。</p></li><li><p><code>--ff-only</code> 表示如果合并过程出现冲突， Git 会自动 abort 此次合并。</p></li></ul></li><li><p><code>--Xours</code> 和 <code>--Xtheirs</code></p><p>用于指定在出现冲突时，完全采用一方的变动而忽略另一方。</p></li><li><p><code>--s</code>, <code>--strategy</code> <strategy></p><p>用于指定合并的策略，合并策略详见上方正文。</p></li><li><p><code>-X</code>, <code>--strategy-option</code></p><p>用于指定合并策略的具体参数。</p></li><li><p><code>-m</code>, <code>--message</code> <message></p><p>用于指定合并的提交信息（仅在非 fast-forward 模式下可用）</p></li><li><p><code>-abort</code></p><p>退出合并（一般在出现冲突时使用）。</p></li></ul><h3 id="rebase-1"><a href="#rebase-1" class="headerlink" title="rebase"></a>rebase</h3><ul><li><p><code>--i</code>, <code>--interactive</code></p><p>打开互动模式，以 GUI 的形式让使用者进行操作。</p></li><li><p><code>--stat</code> 和 <code>-n</code> 以及 <code>--no-stat</code></p><p>同上方 merge</p></li><li><p><code>--continue</code></p><p>表示继续 rebase 流程，通常用于 rebase 处理冲突后。</p></li><li><p><code>--skip</code></p><p>表示直接跳过当前分支的提交，采用目标分支的提交。</p></li><li><p><code>--abort</code></p><p>表示放弃 rebase，并将 HEAD 重置为原始分支。</p></li><li><p><code>--quit</code></p><p>表示放弃 rebase。</p><blockquote><p>和 <code>--abort</code> 的区别： <code>--quit</code> 不会重置工作区和索引</p></blockquote></li></ul><h2 id="附4：cherry-pick-用法"><a href="#附4：cherry-pick-用法" class="headerlink" title="附4：cherry-pick 用法"></a>附4：cherry-pick 用法</h2><ul><li><p>最常见的用法：</p><blockquote><p>注：cherry-pick 后如果使用分支名称，则复制的是分支的最新提交。</p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commitHash&gt;</span><br><span class="line">git cherry-pick &lt;branch&gt;</span><br></pre></td></tr></table></figure></li><li><p>复制多个提交：</p><blockquote><p>注：</p><ol><li>注意顺序，越前面的提交越早</li><li>git cherry-pick commitHash1..commitHashN，这种写法，提交必须是连续的</li></ol></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commitHash1&gt; &lt;commitHash2&gt;</span><br><span class="line">git cherry-pick commitHash1..commitHashN</span><br></pre></td></tr></table></figure></li><li><p><code>--continue</code></p><p>同 rebase</p></li><li><p><code>--abort</code></p><p>同 rebase</p></li><li><p><code>--quit</code></p><p>同 rebase</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git必知必会-基础知识</title>
      <link href="2021/03/08/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/03/08/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么"></a>Git 是什么</h2><p>一个强大的版本控制软件</p><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://git-scm.com/book/zh/v2">官方文档</a></h3><h3 id="交互式学习站点-learngitbranching"><a href="#交互式学习站点-learngitbranching" class="headerlink" title="交互式学习站点-learngitbranching"></a><a href="https://learngitbranching.js.org/">交互式学习站点-learngitbranching</a></h3><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>四种状态：<ul><li>未跟踪：还没有参与版本控制的状态</li><li>已修改：表示修改了文件，但还没保存到数据库中</li><li>已暂存：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li><li>已提交：表示数据已经安全地保存在本地数据库中<br><img src="/2021/03/08/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81.png"></li></ul></li><li>四个区域<ul><li>Git 仓库：是 Git 用来保存项目的元数据和对象数据库的地方</li><li>工作目录：是对项目的某个版本独立提取出来的内容</li><li>暂存区域：保存了下次将要提交的文件列表信息</li><li>远程仓库</li></ul></li></ul><a id="more"></a><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2021/03/08/git%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>Q：clone 失败或者是速度慢<br>A：可以尝试使用</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global http.postBuffer <span class="number">524288000</span></span><br></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>通常是先<strong>获取</strong>再拉取，比较稳，好像没有碰到过什么问题</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>Q：拉取失败<br>A：通常是本地文件冲突导致，在拉取前 commit 或者 stash 一下（尽量操作前都这么做）</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>提交到暂存区</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>将暂存区的改动提交到本地的版本库<br><strong>tips: amend 很好用</strong></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>将本地修改推送到远程仓库<br><strong>tips: 尽量不用 –force 参数</strong></p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>检出，用于切换分支或者提交。</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>分支操作，创建、查看等</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>分支合并。</p><blockquote><p>扩展：分支合并策略，<a href="https://www.jianshu.com/p/58a166f24c81">点我查看文档</a></p></blockquote><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>变基，用的不多，<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">点我查看文档</a></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>重置|回退|撤销，有三种模式：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git reset --soft &amp; :: 软合并，会保存所有本地改动</span><br><span class="line">git reset --mixed &amp; ::  混合合并，保持工作副本并重置索引(即取消暂存)，默认使用该模式</span><br><span class="line">git reset --hard &amp; :: 强行合并，丢弃所有改动的工作副本</span><br></pre></td></tr></table></figure><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>储藏，挺经常用的</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash list &amp; :: 查看 stash 列表</span><br><span class="line">git stash pop [--index] &amp; :: 将最新的 stash 恢复到工作区，恢复后会删除当前 stash</span><br><span class="line">git stash apply [--index] &amp; :: 和 pop 类似，区别是恢复后不会删除当前 stash</span><br></pre></td></tr></table></figure><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>查看操作记录，基本是误操作后使用<br>比如，在进行一个 amend 操作后，发现提交信息错误，想回退。这时候，就可以使用 git reflog 查看 amend 操作前的哈希，然后使用 git reset 进行回退了</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>遴选，用于将指定的提交应用于其他分支</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commitHash&gt; &amp; :: 可以有多个 hash，越往左越早</span><br></pre></td></tr></table></figure><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><h3 id="配置文本编辑器"><a href="#配置文本编辑器" class="headerlink" title="配置文本编辑器"></a>配置文本编辑器</h3><p>配置用于编辑提交以及标签信息的编辑器，默认使用 vim</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global core.editor &quot;code --wait&quot;</span><br><span class="line">git config --global core.editor &quot;vim&quot; &amp; :: 重置为默认编辑器</span><br></pre></td></tr></table></figure><h3 id="配置大小写敏感"><a href="#配置大小写敏感" class="headerlink" title="配置大小写敏感"></a>配置大小写敏感</h3><p>主要在 push 时可能会碰到这个问题，开启大小写敏感</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config core.ignorecase false</span><br></pre></td></tr></table></figure><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>可以通过 git 的别名配置来简化命令的输入，有两种方式</p><ul><li>通过命令行设置：<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure></li><li>将下面的内容复制到：用户文件夹/.gitconfig<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">  # cr &#x3D; code review</span><br><span class="line">  cr &#x3D; !sh -c &#39;git push origin HEAD:refs&#x2F;for&#x2F;$1&#39; -</span><br><span class="line">  ci &#x3D; commit</span><br><span class="line">  ciamend &#x3D; commit --amend -m &#39;&#39;</span><br><span class="line">  patch &#x3D; !sh -c &#39;git ciamend &amp;&amp; git cr $1&#39; -</span><br><span class="line">  st &#x3D; status</span><br><span class="line">  br &#x3D; branch</span><br><span class="line">  co &#x3D; checkout</span><br></pre></td></tr></table></figure></li></ul><h3 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h3><p>总的来说，git 的钩子分为三类：</p><ul><li>提交工作流钩子</li><li>电子邮件工作流钩子</li><li>其它钩子</li></ul><p>比较常用的应该是<strong>提交工作流钩子</strong>，如<code>pre-commit</code>，通常会结合<a href="https://github.com/typicode/husky">husky</a>进行配置。</p><h2 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h2><p>GIt 的 客户端很多，tortoiseGit、 sourceTree、 vscode 的 git graph 插件等等，选一款适合自己的就好了，个人推荐 <code>sourceTree</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
